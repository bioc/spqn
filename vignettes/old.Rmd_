---
title: "Spatial quantile normalization for co-expression analysis"
shorttitle: "spqn guide"
author:
  - Yi Wang
  - Kasper D. Hansen
  - Stephanie C. Hicks
package: SpQN
abstract: >
  A guide to using spqn for co-expression analysis
vignette: >
  %\VignetteIndexEntry{spqn User's Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
output:
  BiocStyle::html_document:
    toc_float: true
---

# Preliminaries


Let's load the package and some example data.

```{load r, message=FALSE}
library(spqn)
library(spqnData)
library(SummarizedExperiment)
data(gtex.4k)
```

This dataset contains 4,000 genes from GTEx tissue "Adipose Subcutaneous" which we use as exemplar tissue in our preprint CITE. The data is from GTEx v6p. The genes have been restricted to a random sample of 4,000 genes from genes which are
- Either protein-coding or linRNAs
- Expressed (median expression greater than 0 on the $\log_2(\text{RPKM})$ scale

The data is counts (from the GTEx website) which has been transformed to $\log_2(\text{RPKM})$ and 4 principal components have been removed from the data matrix. Removing principal components from the data matrix also results in mean-centering. For this reason we need access to the original log-RPKM values (prior to removing principal components); these are stored in `rowData(gtex.4k)$ave_logrpkm`

First we sort the genes according to expression level and then calculate the correlation matrix
```{cor_m r, message=FALSE)
gtex.4k <- gtex.4k[order(rowData(gtex.4k)$ave_logrpkm),]
cor_m <- cor(t(assay(gtex.4k)))
```

# Mean-correlation relationship

We now recreate a number of diagnostic plots which illustrate the mean-correlation relationship

```
IQR_list <- cal_m_sd_IQR(cor_m, rowData(gtex.4k)$ave_logrpkm)

```

```{r, message = F, fig.width = 4, fig.height = 4}
list_IQR_ori = cal_m_sd_IQR(corExprs, exprsData_levels)
#sd_grp_ori=list_IQR_ori$sd_cor_mat
IQR_grp_ori=list_IQR_ori$IQR_cor_mat
grp_mean=list_IQR_ori$grp_mean
```

Ridgeplot for diagonal in cor_ori
```{r, message = F, fig.width = 4, fig.height = 4}
plot_diagonal_ridge4(corExprs)
boxplot(IQR_list$IQR_cor_mat)
```

QQplot for cor_ori
```{r, message = F, fig.width = 3, fig.height = 3}
for(j in 1:10){
    qqplot_density2(cor_m,j,j)
}
```

min-IQR relationship for cor_ori 
```{r, message = F, fig.width = 4, fig.height = 4}
mean_min_ori=c()
IQR_vec_ori=c()
for(i in 1:10){
  for(j  in i:10){
      mean_min_ori=c(mean_min_ori, grp_mean[i])
      IQR_vec_ori=c(IQR_vec_ori, IQR_grp_ori[i,j])
  }
}
range_y=range(IQR_vec_ori)
plot(mean_min_ori,IQR_vec_ori,xlab="min(average(log2CPM))",ylab="IQR",cex.lab=1.5,cex.axis=1.2,col="blue",ylim=range_y)
```

distribution of signals conditional on expression level - cor_ori, top 0.1% correlations
```{r, message = F, fig.width = 4, fig.height = 4}
plot_signal_condition_exp(cor_m, 0.1)
```

# Spatial quantile normzalization

```{spqn r, message = F, fig.width = 4, fig.height = 4}
cor_est=quantile_norm(corExprs,ngrp=20,size_grp=300,ref_grp=18)
```

# Spatial quantile normalization removes the mean-correlation relationship

IQR calculation for cor_adj
```{r, message = F, fig.width = 4, fig.height = 4}
list_IQR_adj = cal_m_sd_IQR(cor_est, exprsData_levels)
IQR_grp_adj=list_IQR_adj$IQR_cor_mat
```

ridgeplot for diagonal in cor_est
```{r, message = F, fig.width = 4, fig.height = 4}
plot_diagonal_ridge4(cor_est)
```

boxplot - IQR for cor_adj
```{r, message = F, fig.width = 4, fig.height = 4}
box_plot(IQR_grp_adj,round(grp_mean,1))
```

qqplot for cor_adj
```{r, message = F, fig.width = 3, fig.height = 3}
for(j in 1:10){
    qqplot_density2(cor_est,j,j)
}
```

min-IQR relationship for cor_adj
```{r, message = F, fig.width = 4, fig.height = 4}
mean_min_adj=c()
IQR_vec_adj=c()
for(i in 1:10){
  for(j  in i:10){
      mean_min_adj=c(mean_min_adj,grp_mean[i])
      IQR_vec_adj=c(IQR_vec_adj,IQR_grp_adj[i,j])
  }
}
range_y=range(IQR_vec_ori)
plot(mean_min_adj,IQR_vec_adj,xlab="min(average(log2CPM))",ylab="IQR",cex.lab=1.5,cex.axis=1.2,col="red",ylim=range_y)
```

distribution of signals conditional on expression level - cor_est, top 0.1% correlations
```{r, message = F, fig.width = 4, fig.height = 4}
plot_signal_condition_exp(cor_est,0.1)
```


compare cor_ori and cor_adj
expression level of signals - top 0.1% correlations
```{r, message = F, fig.width = 4, fig.height = 4}
d0=plot_exp_signal(corExprs,cor_est,exprsData_levels,0.1)
```





# OLD STUFF

```{r, eval=FALSE, message=FALSE, include=FALSE}
library(WGCNA)
library(ggridges)
library(viridis)
library(ggplot2)
library(matrixStats)
root="/Users/yiwang/Dropbox/meanCoexp_Rpackage-master"
source(paste0(root,"/R/functions_2d_quantile.R"))
source(paste0(root,"/R/functions_evaluation.r"))
dir_data=paste0(root,"/data/")
dir_output=paste0(root,"/data/")

list_tissues=c("Adipose_Subcutaneous","Adrenal_Gland","Artery_Tibial","Brain_Cerebellum",
               "Brain_Cortex", "Breast_Mammary","Colon_Transverse","Esophagus_Mucosa","Heart_Left_Ventricle")
i=1
n_PC=27
name_tissue=list_tissues[[i]]
name_var= paste0("counts_gtex_",name_tissue)
load(paste0(dir_data, name_var,".RData" ))
list_filt=rpm_filt_v2(eval(as.name(name_var)))
# extract filtered raw and log2cpm counts
log2cpm_kp=list_filt$counts_log2cpm_keep
keep_filt=list_filt$keep

if(n_PC==0){log2cpm_kp_rmPC=log2cpm_kp}else{log2cpm_kp_rmPC = removePCs(log2cpm_kp,n_PC)}

set.seed(1)
sample_random=sample(1:nrow(log2cpm_kp),4000,replace=F)
log2cpm_kp_rmPC=log2cpm_kp_rmPC[sample_random,]
log2cpm_kp=log2cpm_kp[sample_random,]
corr_ori=cor(t(log2cpm_kp_rmPC[order(rowMeans(log2cpm_kp)),]))
ave_logcpm_kp=rowMeans(log2cpm_kp)[order(rowMeans(log2cpm_kp))]


exprsData_uncorrected <- log2cpm_kp[order(rowMeans(log2cpm_kp)),]
exprsData <- log2cpm_kp_rmPC[order(rowMeans(log2cpm_kp)),]
exprsData_levels <- rowMeans(exprsData_uncorrected)
save(exprsData_uncorrected, file = "../data/exprsData_uncorrected.rda", compress = "xz")
save(exprsData, file = "../data/exprsData.rda")
save(exprsData_levels, file = "../data/exprsData_levels.rda")

```
