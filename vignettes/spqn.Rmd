---
title: "Spatial quantile normalization for co-expression analysis"
shorttitle: "spqn guide"
author:
  - Yi Wang
  - Kasper D. Hansen
  - Stephanie C. Hicks
package: SpQN
abstract: >
  A guide to using spqn for co-expression analysis
bibliography: spqn.bib
vignette: >
  %\VignetteIndexEntry{spqn User's Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
output:
  BiocStyle::html_document:
    toc_float: true
---

# Introduction

The spqn package contains an implementation of spatial quantile normalization (SpQN) as described in [@spqnPreprint]. In this work we describe how correlation matrices estimated from gene expression data exhibits a _mean-correlation_ relationship, in which highly expressed genes appear more correlated than lowly expressed genes. This relationship is not observed in protein-protein interaction networks which suggests it is technical rather than biological. To correct for this, we developed SpQN, a method for normalizing the correlation matrix. In our work, we show how correcting for this relationship increases the correlations involving transcription factors, an important class of gene regulators.

We believe spatial quantile normalization has applications outside of co-expression analysis including beyond correlation matrices. However, the _implementation_ in this package is currently focused on correlation matrices.

The package contains various plotting functions for assessing the mean-correlation relationship, mirroring plots in [@spqnPreprint].


# Preliminaries

Let's load the package and some example data.

```{r load, message=FALSE}
library(spqn)
library(spqnData)
library(SummarizedExperiment)
data(gtex.4k)
```

This dataset contains 4,000 genes from the GTEx tissue "Adipose Subcutaneous" which we use as exemplar tissue in our preprint [@spqnPreprint]. The data is from GTEx v6p. The genes have been restricted to a random sample of 4,000 genes from genes which are
- Either protein-coding or lincRNAs
- Expressed (median expression greater than 0 on the $\log_2(\text{RPKM})$ scale

The data is counts (from the GTEx website) which has been transformed to $\log_2(\text{RPKM})$ and 4 principal components have been removed from the data matrix. Removing principal components from the data matrix also results in mean-centering. For SpQN we need access to the gene expression level, which we take as the mean or median expression level across samples. So this quantity needs to be computed (and stored) prior to removing principal components. For this example data, we have stored the average expression value on the log-RPKM scale in `rowData(gtex.4k)$ave_logrpkm`.

First we sort the genes according to expression level and then calculate the correlation matrix
```{r cor_m, message=FALSE}
gtex.4k <- gtex.4k[order(rowData(gtex.4k)$ave_logrpkm),]
cor_m <- cor(t(assay(gtex.4k)))
ave_logrpkm <- rowData(gtex.4k)$ave_logrpkm
```

# Preparing your own data

**Note**: code in this section is not being evaluated.

We assume you have counts (or something similar) stored in a `SummarizedExperiment`. In our case, we have downloaded the GTEx v6p counts from the GTEx portal website (code is available in the `spqnData` package inside `scripts`. 

It makes sense to do some correction for library size. In this data we have simply divided by the number of reads in millions. There are multiple normalization strategies for estimating a library size correction factor. The literature shows that using such methods are *essential* when comparing expression across different tissues / cell types / conditions. However, here we are looking at correlation patterns **within** tissue.

We also need to remove genes which are not expressed. The threshold we have been using for GTEx is fairly liberal as it removes less than 50% of protein-coding codes. We apply this cutoff on the RPKM scale as it is necessary to consider gene length when applying a cutoff across genes. However, the exact way of doing this is probably not too important.

Finally, following [@Parsana2019] we strongly recommend removing principal components from the data matrix prior to analysis. A fast convenience function for this is `removePrincipalComponents()` from the WGCNA package. How many principal components to remove is an open question. In [@Freytag2015] the authors recommend looking at control genes to assess this, under the hypothesis that random genes should be uncorrelated and we have existing groups of genes which are believe to be highly correlated in all tissues, such as the PRC2 complex [@Freytag2015] or the ribosomal RNA genes [@Boukas2019]. Another approach is to use the `num.sv()` function from the SVA package. In our experience, this yields a substantially higher number of PCs than the graphical methods. Finally, as we shown [@spqnPreprint], the QC plots we present below might also help making this decision. At the end of the day, it is still an open problem.

Example code is as follows, the starting point is a `SummarizedExperiment` called `gtex` with the relevant data. It has two relevant columns in `rowData(gtex)`. One column is `gene_length` and another is `gene_type`.

```{r, examplePreproc, eval=FALSE}
gtex <- gtex[rowData(gtex)$gene_type %in%
                          c("lincRNA", "protein_coding"), ]

cSums <- colSums(assay(gtex))
logrpkm <- sweep(log2(assay(gtex) + 0.5), 2, FUN = "-",
                 STATS = log2(cSums / 10^6))
logrpkm <- logrpkm - log2(rowData(gtex)$gene_length / 1000)

wh.expressed  <- which(rowMedians(logrpkm) > 0)

gtex.0pcs <- gtex[wh.expressed,]
logrpkm.0pcs <- logrpkm[wh.expressed,]
ave_logrpkm <- rowMeans(logrpkm.0pcs)
assays(gtex.0pcs) <- SimpleList(logrpkm = logrpkm.0pcs)
rowData(gtex.0pcs)$ave_logrpkm <- ave_logrpkm

gtex.4pcs <- gtex.0pcs
assay(gtex.4pcs) <- removePrincipalComponents(logrpkm.0pcs, n = 4)
```


# Examining the mean-correlation relationship

We now recreate a number of diagnostic plots which illustrate the mean-correlation relationship. These plots are similar to that is being presented in [@spqnPreprint].

First, to visualize the mean-correlation relationship, group the genes by expression level and compare the distribution of correlations in each group.
```{r, message=FALSE, fig.width=4, fig.height=4}
plot_signal_condition_exp(cor_m, ave_logrpkm, 0)
```

Next, to examine the downstream effect of the mean-correlation relationship, compare the separation of signal and background conditional on different expression levels, i.e. compare the distribution of correlations between signals and background in each group. Here we define signal as 0.1% highest absolute correlations in each group.
```{r, message = FALSE, fig.width = 4, fig.height = 4}
plot_signal_condition_exp(cor_m, ave_logrpkm, 0.1)
```

Then compare the IQR of correlations for genes in each expression level, by gridding the correlation matrix into 10 by 10 bins, and compute the interquartile ranges (IQRs) for each bin, and plot them (the width of each box).
```{r, message=FALSE}
IQR_list <- get_IQR_condition_exp(cor_m, rowData(gtex.4k)$ave_logrpkm)
box_plot(IQR_list)
```

Furthermore, find the marginal relationship between the lowest of the two expression bins and IQR 
```{r, message = FALSE, fig.width = 4, fig.height = 4}
IQR_unlist <- unlist(lapply(1:10, function(ii) IQR_list$IQR_cor_mat[ii, ii:10]))
plot(rep(IQR_list$grp_mean, times = 1:10),
     IQR_unlist,
     xlab="min(average(log2RPKM))", ylab="IQR", cex.lab=1.5, cex.axis=1.2, col="blue")
```

Next, compare the distribution between each bin and the reference bin (here we use the (9,9) bin) by qqplot 
```{r, message = FALSE, fig.width = 4, fig.height = 4}
par(mfrow = c(3,3))
for(j in 1:10){
    qqplot_condition_exp(cor_m, ave_logrpkm, j, j)
}
```



# Using SpQN

Using SpQN is relatively easy. Currently, we assume that the correlation matrix is sorted by expression level as shown above. With that in mind, we do

```{r spqn, message = FALSE, fig.width = 4, fig.height = 4}
cor_m_spqn <- normalize_correlation(cor_m, ave_logrpkm, ngrp=20, size_grp=300, ref_grp=18)
```

FIXME: explain the arguments.

# Assess the impact of normalization

As QC, we make the same plots we did above, but with the corrected data.


Compare the distribution of correlations in each expression level
```{r, message = FALSE, fig.width = 4, fig.height = 4}
plot_signal_condition_exp(cor_m_spqn, ave_logrpkm, 0)
```

Compare the separation of signal and background conditional on different expression levels
```{r, message = FALSE, fig.width = 4, fig.height = 4}
plot_signal_condition_exp(cor_m_spqn, ave_logrpkm, 0.1)
```

Compare the IQR of correlations for genes in each expression level
```{r, message=FALSE}
IQR_spqn_list <- get_IQR_condition_exp(cor_m_spqn, rowData(gtex.4k)$ave_logrpkm)
box_plot(IQR_spqn_list)
```

Compare the distribution of each bin and the reference bin, using qqplot
```{r, message = FALSE, fig.width = 3, fig.height = 3}
par(mfrow = c(3,3))
for(j in 1:10){
    qqplot_condition_exp(cor_m_spqn, ave_logrpkm, j, j)
}
```

Find the marginal relationship between the lowest of the two expression bins and IQR 
```{r, message = FALSE, fig.width = 4, fig.height = 4}
IQR_unlist <- unlist(lapply(1:10, function(ii) IQR_spqn_list$IQR_cor_mat[ii, ii:10]))
plot(rep(IQR_spqn_list$grp_mean, times = 1:10),
     IQR_unlist,
     xlab="min(average(log2RPKM))", ylab="IQR", cex.lab=1.5, cex.axis=1.2, col="blue")
```

# SessionInfo

```{r sessionInfo}
sessionInfo()
```

# References
