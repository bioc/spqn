---
title: "Spatial quantile normalization for co-expression analysis"
shorttitle: "spqn guide"
author:
  - Yi Wang
  - Kasper D. Hansen
package: spqn
abstract: >
  A guide to using spqn for co-expression analysis
vignette: >
  %\VignetteIndexEntry{spqn User's Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
output:
  BiocStyle::html_document:
    toc_float: true
---

# Preliminaries

```{r, eval=FALSE, message=FALSE, include=FALSE}
library(WGCNA)
library(ggridges)
library(viridis)
library(ggplot2)
library(matrixStats)
root="/Users/yiwang/Dropbox/meanCoexp_Rpackage-master"
source(paste0(root,"/R/functions_2d_quantile.R"))
source(paste0(root,"/R/functions_evaluation.r"))
dir_data=paste0(root,"/data/")
dir_output=paste0(root,"/data/")

list_tissues=c("Adipose_Subcutaneous","Adrenal_Gland","Artery_Tibial","Brain_Cerebellum",
               "Brain_Cortex", "Breast_Mammary","Colon_Transverse","Esophagus_Mucosa","Heart_Left_Ventricle")
i=1
n_PC=27
name_tissue=list_tissues[[i]]
name_var= paste0("counts_gtex_",name_tissue)
load(paste0(dir_data, name_var,".RData" ))
list_filt=rpm_filt_v2(eval(as.name(name_var)))
# extract filtered raw and log2cpm counts
log2cpm_kp=list_filt$counts_log2cpm_keep
keep_filt=list_filt$keep

if(n_PC==0){log2cpm_kp_rmPC=log2cpm_kp}else{log2cpm_kp_rmPC = removePCs(log2cpm_kp,n_PC)}

set.seed(1)
sample_random=sample(1:nrow(log2cpm_kp),4000,replace=F)
log2cpm_kp_rmPC=log2cpm_kp_rmPC[sample_random,]
log2cpm_kp=log2cpm_kp[sample_random,]
corr_ori=cor(t(log2cpm_kp_rmPC[order(rowMeans(log2cpm_kp)),]))
ave_logcpm_kp=rowMeans(log2cpm_kp)[order(rowMeans(log2cpm_kp))]


exprsData_uncorrected <- log2cpm_kp[order(rowMeans(log2cpm_kp)),]
exprsData <- log2cpm_kp_rmPC[order(rowMeans(log2cpm_kp)),]
exprsData_levels <- rowMeans(exprsData_uncorrected)
save(exprsData_uncorrected, file = "../data/exprsData_uncorrected.rda", compress = "xz")
save(exprsData, file = "../data/exprsData.rda")
save(exprsData_levels, file = "../data/exprsData_levels.rda")

```

Let's load the package and some example data.

```{load r, message=FALSE}
library(spqn)
library(spqnDataTemp)
library(ggplot2)
library(ggridges)
data(exprsData)
data(exprsData_levels)
corExprs <- cor(t(exprsData))
```

# Mean-correlation relationship


IQR calculation for cor_ori
```{r, message = F, fig.width = 4, fig.height = 4}
list_IQR_ori = cal_m_sd_IQR(corExprs, exprsData_levels)
#sd_grp_ori=list_IQR_ori$sd_cor_mat
IQR_grp_ori=list_IQR_ori$IQR_cor_mat
grp_mean=list_IQR_ori$grp_mean
```

Ridgeplot for diagonal in cor_ori
```{r, message = F, fig.width = 4, fig.height = 4}
plot_diagonal_ridge4(corExprs)
```

Boxplot - IQR for cor_ori
```{r, message = F, fig.width = 4, fig.height = 4}
box_plot(IQR_grp_ori,round(grp_mean,1))
```

QQplot for cor_ori
```{r, message = F, fig.width = 3, fig.height = 3}
for(j in 1:10){
    qqplot_density2(corExprs,j,j)
}
```

min-IQR relationship for cor_ori 
```{r, message = F, fig.width = 4, fig.height = 4}
mean_min_ori=c()
IQR_vec_ori=c()
for(i in 1:10){
  for(j  in i:10){
      mean_min_ori=c(mean_min_ori,grp_mean[i])
      IQR_vec_ori=c(IQR_vec_ori,IQR_grp_ori[i,j])
  }
}
range_y=range(IQR_vec_ori)
plot(mean_min_ori,IQR_vec_ori,xlab="min(average(log2CPM))",ylab="IQR",cex.lab=1.5,cex.axis=1.2,col="blue",ylim=range_y)
```

distribution of signals conditional on expression level - cor_ori, top 0.1% correlations
```{r, message = F, fig.width = 4, fig.height = 4}
plot_signal_condition_exp(corExprs,0.1)
```

# Spatial quantile normzalization

```{spqn r, message = F, fig.width = 4, fig.height = 4}
cor_est=quantile_norm(corExprs,ngrp=20,size_grp=300,ref_grp=18)
```

# Spatial quantile normalization removes the mean-correlation relationship

IQR calculation for cor_adj
```{r, message = F, fig.width = 4, fig.height = 4}
list_IQR_adj = cal_m_sd_IQR(cor_est, exprsData_levels)
IQR_grp_adj=list_IQR_adj$IQR_cor_mat
```

ridgeplot for diagonal in cor_est
```{r, message = F, fig.width = 4, fig.height = 4}
plot_diagonal_ridge4(cor_est)
```

boxplot - IQR for cor_adj
```{r, message = F, fig.width = 4, fig.height = 4}
box_plot(IQR_grp_adj,round(grp_mean,1))
```

qqplot for cor_adj
```{r, message = F, fig.width = 3, fig.height = 3}
for(j in 1:10){
    qqplot_density2(cor_est,j,j)
}
```

min-IQR relationship for cor_adj
```{r, message = F, fig.width = 4, fig.height = 4}
mean_min_adj=c()
IQR_vec_adj=c()
for(i in 1:10){
  for(j  in i:10){
      mean_min_adj=c(mean_min_adj,grp_mean[i])
      IQR_vec_adj=c(IQR_vec_adj,IQR_grp_adj[i,j])
  }
}
range_y=range(IQR_vec_ori)
plot(mean_min_adj,IQR_vec_adj,xlab="min(average(log2CPM))",ylab="IQR",cex.lab=1.5,cex.axis=1.2,col="red",ylim=range_y)
```

distribution of signals conditional on expression level - cor_est, top 0.1% correlations
```{r, message = F, fig.width = 4, fig.height = 4}
plot_signal_condition_exp(cor_est,0.1)
```


compare cor_ori and cor_adj
expression level of signals - top 0.1% correlations
```{r, message = F, fig.width = 4, fig.height = 4}
d0=plot_exp_signal(corExprs,cor_est,exprsData_levels,0.1)
```
